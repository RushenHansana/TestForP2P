{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\disan\\\\OneDrive\\\\Documents\\\\NCINGA\\\\Test\\\\users\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\n// // App.js\n// import React, { useEffect, useRef, useState } from \"react\";\n// import io from \"socket.io-client\";\n\n// const socket = io.connect(\"http://localhost:5000\"); // Connect to signaling server\n\n// function App() {\n//   const [roomID, setRoomID] = useState(\"\");\n//   const [stream, setStream] = useState(null);\n//   const myVideo = useRef();\n//   const remoteVideo = useRef();\n//   const peerConnection = useRef(null);\n//   const [usersJoined, setUsersJoined] = useState([]);\n\n//   useEffect(() => {\n//     // Fetch room ID only once when the component mounts\n//     const url = window.location.href;\n//     const splitURL = url.split(\"/\");\n//     const roomIDFromURL = splitURL[splitURL.length - 1];\n//     setRoomID(roomIDFromURL);\n//     console.log(\"Room ID:\", roomIDFromURL);\n\n//     // Get user media\n//     navigator.mediaDevices\n//       .getUserMedia({\n//         video: true,\n//         audio: true,\n//       })\n//       .then((stream) => {\n//         setStream(stream);\n//         myVideo.current.srcObject = stream;\n\n//         // Establish connection with signaling server\n//         socket.emit(\"joinRoom\", roomIDFromURL);\n//       })\n//       .catch((error) => {\n//         console.error(\"Error accessing media devices:\", error);\n//       });\n\n//     socket.on(\"receiveIceCandidate\", (data) => {\n//       // Add the received ICE candidate to the peer connection\n//       if (peerConnection.current) {\n//         peerConnection.current.addIceCandidate(data.candidate);\n//       }\n//     });\n\n//     // Handle new user joined the room\n//     socket.on(\"userJoined\", (users) => {\n//       setUsersJoined(users);\n\n//       // Create a new peer connection for each user who joins the room\n//       users.forEach((user) => {\n//         if (user !== socket.id) {\n//           const peer = new RTCPeerConnection({\n//             iceServers: [\n//               { urls: \"stun:stun.l.google.com:19302\" },\n//               { urls: \"stun:stun1.l.google.com:19302\" },\n//             ],\n//           });\n\n//           // Add tracks to the peer connection\n//           if (stream) {\n//             stream.getTracks().forEach((track) => {\n//               peer.addTrack(track, stream);\n//             });\n//           }\n\n//           // Set up event listeners for the peer connection\n//           peer.onicecandidate = (event) => {\n//             if (event.candidate) {\n//               // Send ICE candidate to the signaling server\n//               socket.emit(\"sendIceCandidate\", {\n//                 candidate: event.candidate,\n//                 to: user,\n//               });\n//             }\n//           };\n\n//           peer.ontrack = (event) => {\n//             // Add the remote stream to the video element\n//             if (event.streams && event.streams[0]) {\n//               remoteVideo.current.srcObject = event.streams[0];\n//             }\n//           };\n\n//           // Create offer and set local description\n//           peer.createOffer()\n//             .then((offer) => peer.setLocalDescription(offer))\n//             .then(() => {\n//               // Emit the offer to the signaling server\n//               socket.emit(\"callUser\", {\n//                 userToCall: user,\n//                 signalData: peer.localDescription,\n//                 from: socket.id,\n//               });\n//             })\n//             .catch((error) => {\n//               console.error(\"Error creating or setting local description:\", error);\n//             });\n\n//           // Store the peer connection in a reference\n//           peerConnection.current = peer;\n//         }\n//       });\n//     });\n\n//     return () => {\n//       // Clean up event listeners\n//       socket.off(\"receiveIceCandidate\");\n//       socket.off(\"callAccepted\");\n//     };\n//   }, []); // Empty dependency array ensures useEffect runs only once\n\n//   const handleToggleMic = () => {\n//     if (stream) {\n//       const audioTracks = stream.getAudioTracks();\n//       audioTracks.forEach((track) => {\n//         track.enabled = !track.enabled;\n//       });\n//     }\n//   };\n\n//   const handleToggleCamera = () => {\n//     if (stream) {\n//       const videoTracks = stream.getVideoTracks();\n//       videoTracks.forEach((track) => {\n//         track.enabled = !track.enabled;\n//       });\n//     }\n//   };\n\n//   return (\n//     <div>\n//       <video ref={myVideo} autoPlay muted style={{ width: \"300px\" }} />\n//       <video ref={remoteVideo} autoPlay style={{ width: \"300px\" }} />\n//       <button onClick={handleToggleMic}>Toggle Mic</button>\n//       <button onClick={handleToggleCamera}>Toggle Camera</button>\n//     </div>\n//   );\n// }\n\n// export default App;\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport Peer from \"simple-peer\";\nimport io from \"socket.io-client\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst socket = io.connect(\"http://localhost:5000\"); // Connect to signaling server\n\nfunction App() {\n  _s();\n  const [stream, setStream] = useState(null);\n  const [callAccepted, setCallAccepted] = useState(false);\n  const [callEnded, setCallEnded] = useState(false);\n  const myVideo = useRef();\n  const userVideo = useRef();\n  const connectionRef = useRef();\n  const [roomID, setRoomID] = useState(\"\");\n  const [userJoinedHandled, setUserJoinedHandled] = useState(false); // Flag to track if userJoined event has been handled\n\n  useEffect(() => {\n    // Extract room ID from URL\n    const url = window.location.href;\n    const splitURL = url.split(\"/\");\n    const roomIDFromURL = splitURL[splitURL.length - 1];\n    setRoomID(roomIDFromURL);\n\n    // Get user media\n    navigator.mediaDevices.getUserMedia({\n      video: true,\n      audio: true\n    }).then(currentStream => {\n      setStream(currentStream);\n      myVideo.current.srcObject = currentStream;\n\n      // Join the room automatically when the component mounts\n      socket.emit(\"joinRoom\", roomIDFromURL);\n    }).catch(error => {\n      console.error(\"Error accessing media devices:\", error);\n    });\n    socket.on(\"userJoined\", user => {\n      if (!userJoinedHandled && user !== socket.id) {\n        setUserJoinedHandled(true); // Set the flag to true to prevent further handling\n        const peer = new Peer({\n          initiator: true,\n          trickle: false,\n          stream: stream,\n          config: {\n            iceServers: [{\n              urls: \"stun:stun.l.google.com:19302\"\n            }, {\n              urls: \"stun:stun1.l.google.com:19302\"\n            }, {\n              urls: \"stun:stun2.l.google.com:19302\"\n            }]\n          }\n        });\n        peer.on(\"signal\", data => {\n          socket.emit(\"callUser\", {\n            userToCall: user,\n            signalData: data,\n            from: socket.id\n          });\n        });\n        peer.on(\"stream\", stream => {\n          userVideo.current.srcObject = stream;\n        });\n        socket.on(\"callAccepted\", signal => {\n          setCallAccepted(true);\n          peer.signal(signal);\n        });\n        connectionRef.current = peer;\n      }\n    });\n    socket.on(\"callUser\", ({\n      signalData,\n      from\n    }) => {\n      if (from !== socket.id) {\n        setCallAccepted(false);\n        const peer = new Peer({\n          initiator: false,\n          trickle: false,\n          stream: stream,\n          config: {\n            iceServers: [{\n              urls: \"stun:stun.l.google.com:19302\"\n            }, {\n              urls: \"stun:stun1.l.google.com:19302\"\n            }, {\n              urls: \"stun:stun2.l.google.com:19302\"\n            }]\n          }\n        });\n        peer.on(\"signal\", data => {\n          socket.emit(\"callAccepted\", {\n            signal: data,\n            to: from\n          });\n        });\n        peer.on(\"stream\", stream => {\n          userVideo.current.srcObject = stream;\n        });\n        peer.signal(signalData);\n        connectionRef.current = peer;\n      }\n    });\n    socket.on(\"callEnded\", () => {\n      setCallEnded(true);\n      connectionRef.current.destroy();\n    });\n    return () => {\n      socket.off(\"userJoined\");\n      socket.off(\"callUser\");\n      socket.off(\"callAccepted\");\n      socket.off(\"callEnded\");\n    };\n  }, [roomID, userJoinedHandled]); // Include userJoinedHandled in the dependency array\n\n  const leaveCall = () => {\n    setCallEnded(true);\n    connectionRef.current.destroy();\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"video-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"video\",\n        children: stream && /*#__PURE__*/_jsxDEV(\"video\", {\n          playsInline: true,\n          muted: true,\n          ref: myVideo,\n          autoPlay: true,\n          style: {\n            width: \"300px\"\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 273,\n          columnNumber: 22\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 272,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"video\",\n        children: callAccepted && !callEnded ? /*#__PURE__*/_jsxDEV(\"video\", {\n          playsInline: true,\n          ref: userVideo,\n          autoPlay: true,\n          style: {\n            width: \"600px\"\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 276,\n          columnNumber: 41\n        }, this) : null\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 275,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 271,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"myId\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 279,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 270,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"kdCvb16cu5sndhkXQFJCTh63sec=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useRef","useState","Peer","io","jsxDEV","_jsxDEV","socket","connect","App","_s","stream","setStream","callAccepted","setCallAccepted","callEnded","setCallEnded","myVideo","userVideo","connectionRef","roomID","setRoomID","userJoinedHandled","setUserJoinedHandled","url","window","location","href","splitURL","split","roomIDFromURL","length","navigator","mediaDevices","getUserMedia","video","audio","then","currentStream","current","srcObject","emit","catch","error","console","on","user","id","peer","initiator","trickle","config","iceServers","urls","data","userToCall","signalData","from","signal","to","destroy","off","leaveCall","className","children","playsInline","muted","ref","autoPlay","style","width","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/disan/OneDrive/Documents/NCINGA/Test/users/src/App.js"],"sourcesContent":["// // App.js\r\n// import React, { useEffect, useRef, useState } from \"react\";\r\n// import io from \"socket.io-client\";\r\n\r\n// const socket = io.connect(\"http://localhost:5000\"); // Connect to signaling server\r\n\r\n// function App() {\r\n//   const [roomID, setRoomID] = useState(\"\");\r\n//   const [stream, setStream] = useState(null);\r\n//   const myVideo = useRef();\r\n//   const remoteVideo = useRef();\r\n//   const peerConnection = useRef(null);\r\n//   const [usersJoined, setUsersJoined] = useState([]);\r\n\r\n//   useEffect(() => {\r\n//     // Fetch room ID only once when the component mounts\r\n//     const url = window.location.href;\r\n//     const splitURL = url.split(\"/\");\r\n//     const roomIDFromURL = splitURL[splitURL.length - 1];\r\n//     setRoomID(roomIDFromURL);\r\n//     console.log(\"Room ID:\", roomIDFromURL);\r\n\r\n//     // Get user media\r\n//     navigator.mediaDevices\r\n//       .getUserMedia({\r\n//         video: true,\r\n//         audio: true,\r\n//       })\r\n//       .then((stream) => {\r\n//         setStream(stream);\r\n//         myVideo.current.srcObject = stream;\r\n\r\n//         // Establish connection with signaling server\r\n//         socket.emit(\"joinRoom\", roomIDFromURL);\r\n//       })\r\n//       .catch((error) => {\r\n//         console.error(\"Error accessing media devices:\", error);\r\n//       });\r\n\r\n//     socket.on(\"receiveIceCandidate\", (data) => {\r\n//       // Add the received ICE candidate to the peer connection\r\n//       if (peerConnection.current) {\r\n//         peerConnection.current.addIceCandidate(data.candidate);\r\n//       }\r\n//     });\r\n  \r\n//     // Handle new user joined the room\r\n//     socket.on(\"userJoined\", (users) => {\r\n//       setUsersJoined(users);\r\n\r\n//       // Create a new peer connection for each user who joins the room\r\n//       users.forEach((user) => {\r\n//         if (user !== socket.id) {\r\n//           const peer = new RTCPeerConnection({\r\n//             iceServers: [\r\n//               { urls: \"stun:stun.l.google.com:19302\" },\r\n//               { urls: \"stun:stun1.l.google.com:19302\" },\r\n//             ],\r\n//           });\r\n  \r\n//           // Add tracks to the peer connection\r\n//           if (stream) {\r\n//             stream.getTracks().forEach((track) => {\r\n//               peer.addTrack(track, stream);\r\n//             });\r\n//           }\r\n  \r\n//           // Set up event listeners for the peer connection\r\n//           peer.onicecandidate = (event) => {\r\n//             if (event.candidate) {\r\n//               // Send ICE candidate to the signaling server\r\n//               socket.emit(\"sendIceCandidate\", {\r\n//                 candidate: event.candidate,\r\n//                 to: user,\r\n//               });\r\n//             }\r\n//           };\r\n  \r\n//           peer.ontrack = (event) => {\r\n//             // Add the remote stream to the video element\r\n//             if (event.streams && event.streams[0]) {\r\n//               remoteVideo.current.srcObject = event.streams[0];\r\n//             }\r\n//           };\r\n  \r\n//           // Create offer and set local description\r\n//           peer.createOffer()\r\n//             .then((offer) => peer.setLocalDescription(offer))\r\n//             .then(() => {\r\n//               // Emit the offer to the signaling server\r\n//               socket.emit(\"callUser\", {\r\n//                 userToCall: user,\r\n//                 signalData: peer.localDescription,\r\n//                 from: socket.id,\r\n//               });\r\n//             })\r\n//             .catch((error) => {\r\n//               console.error(\"Error creating or setting local description:\", error);\r\n//             });\r\n  \r\n//           // Store the peer connection in a reference\r\n//           peerConnection.current = peer;\r\n//         }\r\n//       });\r\n//     });\r\n\r\n//     return () => {\r\n//       // Clean up event listeners\r\n//       socket.off(\"receiveIceCandidate\");\r\n//       socket.off(\"callAccepted\");\r\n//     };\r\n//   }, []); // Empty dependency array ensures useEffect runs only once\r\n\r\n//   const handleToggleMic = () => {\r\n//     if (stream) {\r\n//       const audioTracks = stream.getAudioTracks();\r\n//       audioTracks.forEach((track) => {\r\n//         track.enabled = !track.enabled;\r\n//       });\r\n//     }\r\n//   };\r\n\r\n//   const handleToggleCamera = () => {\r\n//     if (stream) {\r\n//       const videoTracks = stream.getVideoTracks();\r\n//       videoTracks.forEach((track) => {\r\n//         track.enabled = !track.enabled;\r\n//       });\r\n//     }\r\n//   };\r\n\r\n//   return (\r\n//     <div>\r\n//       <video ref={myVideo} autoPlay muted style={{ width: \"300px\" }} />\r\n//       <video ref={remoteVideo} autoPlay style={{ width: \"300px\" }} />\r\n//       <button onClick={handleToggleMic}>Toggle Mic</button>\r\n//       <button onClick={handleToggleCamera}>Toggle Camera</button>\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default App;\r\n\r\n\r\nimport React, { useEffect, useRef, useState } from \"react\";\r\nimport Peer from \"simple-peer\";\r\nimport io from \"socket.io-client\";\r\n\r\nconst socket = io.connect(\"http://localhost:5000\"); // Connect to signaling server\r\n\r\nfunction App() {\r\n  const [stream, setStream] = useState(null);\r\n  const [callAccepted, setCallAccepted] = useState(false);\r\n  const [callEnded, setCallEnded] = useState(false);\r\n  const myVideo = useRef();\r\n  const userVideo = useRef();\r\n  const connectionRef = useRef();\r\n  const [roomID, setRoomID] = useState(\"\");\r\n  const [userJoinedHandled, setUserJoinedHandled] = useState(false); // Flag to track if userJoined event has been handled\r\n\r\n  useEffect(() => {\r\n    // Extract room ID from URL\r\n    const url = window.location.href;\r\n    const splitURL = url.split(\"/\");\r\n    const roomIDFromURL = splitURL[splitURL.length - 1];\r\n    setRoomID(roomIDFromURL);\r\n\r\n    // Get user media\r\n    navigator.mediaDevices\r\n      .getUserMedia({\r\n        video: true,\r\n        audio: true,\r\n      })\r\n      .then((currentStream) => {\r\n        setStream(currentStream);\r\n        myVideo.current.srcObject = currentStream;\r\n\r\n        // Join the room automatically when the component mounts\r\n        socket.emit(\"joinRoom\", roomIDFromURL);\r\n      })\r\n      .catch((error) => {\r\n        console.error(\"Error accessing media devices:\", error);\r\n      });\r\n\r\n    socket.on(\"userJoined\", (user) => {\r\n      if (!userJoinedHandled && user !== socket.id) {\r\n        setUserJoinedHandled(true); // Set the flag to true to prevent further handling\r\n        const peer = new Peer({\r\n          initiator: true,\r\n          trickle: false,\r\n          stream: stream,\r\n          config: {\r\n            iceServers: [\r\n              { urls: \"stun:stun.l.google.com:19302\" },\r\n              { urls: \"stun:stun1.l.google.com:19302\" },\r\n              { urls: \"stun:stun2.l.google.com:19302\" }\r\n            ]\r\n          }\r\n        });\r\n\r\n        peer.on(\"signal\", (data) => {\r\n          socket.emit(\"callUser\", {\r\n            userToCall: user,\r\n            signalData: data,\r\n            from: socket.id,\r\n          });\r\n        });\r\n\r\n        peer.on(\"stream\", (stream) => {\r\n          userVideo.current.srcObject = stream;\r\n        });\r\n\r\n        socket.on(\"callAccepted\", (signal) => {\r\n          setCallAccepted(true);\r\n          peer.signal(signal);\r\n        });\r\n\r\n        connectionRef.current = peer;\r\n      }\r\n    });\r\n\r\n    socket.on(\"callUser\", ({ signalData, from }) => {\r\n      if (from !== socket.id) {\r\n        setCallAccepted(false);\r\n        const peer = new Peer({\r\n          initiator: false,\r\n          trickle: false,\r\n          stream: stream,\r\n          config: {\r\n            iceServers: [\r\n              { urls: \"stun:stun.l.google.com:19302\" },\r\n              { urls: \"stun:stun1.l.google.com:19302\" },\r\n              { urls: \"stun:stun2.l.google.com:19302\" }\r\n            ]\r\n          }\r\n        });\r\n\r\n        peer.on(\"signal\", (data) => {\r\n          socket.emit(\"callAccepted\", { signal: data, to: from });\r\n        });\r\n\r\n        peer.on(\"stream\", (stream) => {\r\n          userVideo.current.srcObject = stream;\r\n        });\r\n\r\n        peer.signal(signalData);\r\n        connectionRef.current = peer;\r\n      }\r\n    });\r\n\r\n    socket.on(\"callEnded\", () => {\r\n      setCallEnded(true);\r\n      connectionRef.current.destroy();\r\n    });\r\n\r\n    return () => {\r\n      socket.off(\"userJoined\");\r\n      socket.off(\"callUser\");\r\n      socket.off(\"callAccepted\");\r\n      socket.off(\"callEnded\");\r\n    };\r\n  }, [roomID, userJoinedHandled]); // Include userJoinedHandled in the dependency array\r\n\r\n  const leaveCall = () => {\r\n    setCallEnded(true);\r\n    connectionRef.current.destroy();\r\n  };\r\n\r\n  return (\r\n    <div className=\"container\">\r\n      <div className=\"video-container\">\r\n        <div className=\"video\">\r\n          {stream && <video playsInline muted ref={myVideo} autoPlay style={{ width: \"300px\" }} />}\r\n        </div>\r\n        <div className=\"video\">\r\n          {callAccepted && !callEnded ? <video playsInline ref={userVideo} autoPlay style={{ width: \"600px\" }} /> : null}\r\n        </div>\r\n      </div>\r\n      <div className=\"myId\">\r\n        {/* Add UI elements as needed */}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}